<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基础cpu介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/22/基础cpu介绍/" class="article-date">
  <time datetime="2017-06-22T02:40:12.000Z" itemprop="datePublished">2017-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/22/基础cpu介绍/">基础cpu介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>cpu </p>
<p>一颗cpu好坏现在主要看：</p>
<p>主频<br>外频<br>缓存<br>指令集<br>是否支持睿频</p>
<hr>
<p>inter cpu 从低到高分为：</p>
<ol start="0">
<li>Atom     凌动 for 上网本、平板</li>
<li>Celeron  赛扬 </li>
<li>Pentium  奔腾 </li>
<li>Core     酷睿</li>
<li>Xeno     至强 for 服务器</li>
</ol>
<hr>
<p>现在常用的酷睿系列又分为：</p>
<ol>
<li>i3  双核4线程，集成gpu，无睿频基数</li>
<li>i5  四核4线程，有睿频技术</li>
<li>i7  四核8线程，高性能，高功耗</li>
</ol>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fgl41j3u2ej30bf09cjsi.jpg" alt=""></p>
<p>cpu的线程 和 核心数<br>核心分为：</p>
<ol>
<li>每核心单线程</li>
<li>每核心双线程  </li>
</ol>
<p>线程是指cpu可以同时处理的进程数量</p>
<hr>
<p>每个cpu型号尾部的字母：</p>
<ol start="0">
<li>y  超低功耗版，不支持睿频，适用上网本</li>
<li>u  低电压版，适用超极本</li>
<li>m  标准电压版</li>
<li>h  同m一样，焊在主板上，不可更换</li>
<li>mq 移动标压四核版，一般是酷睿i7  </li>
</ol>
<p>同型号cpu又分：</p>
<ol>
<li>笔记本版</li>
<li>台式版</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/22/基础cpu介绍/" data-id="cji413o0l000908anc5r7lsnr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-常用疾病治疗方式带来的危害" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/16/常用疾病治疗方式带来的危害/" class="article-date">
  <time datetime="2017-06-16T10:17:29.000Z" itemprop="datePublished">2017-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/16/常用疾病治疗方式带来的危害/">常用疾病治疗方式带来的危害</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>常用疾病治疗方式带来的危害，这里只提部分笔者能想到的。</p>
<p>一、输液<br>先排除：无菌操作、注射器卫生、专业操作、药物安全等的不达标问题 和 药物过敏问题。</p>
<ol>
<li><p>循环负荷过高而诱发 肺水肿：短时间内血管输入大量液体，使得循环血容量剧增，而血液流动的引擎就是心脏。<br>　　一个60kg重的成年人血量约为4200ml，而粗略平均计算，感冒发烧选择输液一次大约800ml的量。<br>　　这里做个比喻：一个日常走路没有冗余负重的人，负重自己体重的800/4200=19%，例如60kg的人负重11.4kg走上两公里，什么感觉？</p>
</li>
<li><p>空气栓塞：输液过程中，各种原因导致少量空气进入静脉，就会让人有以下症状：胸部异常不舒服、呼吸困难、缺氧。</p>
</li>
<li><p>静脉炎症：平时血液浓度正常时，血管及血液内成员生存环境也正常，如果长期输入浓度高、刺激强的药液，血管内成员的生存环境变化，血管出现炎症。<br>　　再来个比喻：三伏天，坐在恒温25℃办公室里的人，突然出门到大街上持续1小时，什么感觉？</p>
</li>
<li><p>血栓、肺组织硬化、肉芽肿：输液的药液里有不溶性微粒，常人肉眼只能看到50微米以上的颗粒，而这些不溶性微粒小于50微米，眼睛看不到，输入血管中。而人身体发展到到这种地步，生理本身并没有将小微粒排出体外的能力，所以这些微粒就会蓄积在身体内的毛细血管中。网上有报：北京某医院对此做调查，500ml药液有20万个微粒，word哥！！！<br>　　而微粒堵积会导致微血管血栓、出血、静脉压增高、肺动脉压增高、肺纤维化；从而导致局部供血不足、组织缺血、缺氧、水肿及炎症、过敏。而被身体巨噬细胞吞噬后，同样无法排出身体，会造成巨噬细胞增大，形成肉芽肿。</p>
</li>
</ol>
<p>医生在输液前多会问：是否对某某药素过敏？  </p>
<p>自己身体对什么过敏，一定要清楚，如果遇到输液输入过敏药物，分分钟要命是很正常的。</p>
<p>二、肌肉注射<br>　　原理：</p>
<ol>
<li>药品溶于组织液后 -&gt; </li>
<li>进入毛细血管网再汇入静脉或者直接进入小静脉或者进入淋巴液再汇入大静脉 -&gt; </li>
<li>随静脉血入右房，再入右室 -&gt; </li>
<li>经肺循环后回到左房 -&gt; </li>
<li>再左室，进入体循环，到达肝脏 -&gt; </li>
<li>肝脏代谢出活性成分，再随血流达到全身或病灶。若不需代谢即有活性，就不需进入肝脏就能直接到全身。</li>
</ol>
<p>肌肉注射的药液需要经过血管壁吸收，多了一层过滤，且注射量一般不大，所以对于药液微粒的危害 和 心脏负担增大的危害 就可以忽略了，所以讨论肌肉注射的危害，就要降低一个级别来讨论了，如下：</p>
<ol>
<li>容易伤及坐骨神经</li>
<li>打破身体免疫系统平衡，短时间（半小时）内人体第三道防线环境改变，能力削弱，面对病菌病毒，基本全靠打入的药物。<br>　　如果身体患集中综合疾病，而摄入的药物仅仅针对某一种疾病，那么短时间内等于给了其他病症肆意妄为的机会。</li>
<li>卫生问题，由于针头是直接刺入皮肉，如果针头携带病菌，那么这些病菌等于被送入体内。</li>
<li>频繁肌肉注射，会让注射部位肌肉来不及修复，造成组织硬化、肌肉萎缩等伤害。健身知识里：肌肉撕裂后修复需要24-72小时。</li>
</ol>
<p>由此看，肌肉注射不像吊瓶，它不能连续对一个部位进行，否则很高概率对组织造成不可逆性伤害。</p>
<p>一、吃药</p>
<p>口服药物治疗原理：</p>
<ol>
<li>药物通过口服进入胃部、小肠、直肠</li>
<li>从胃部开始药物的吸收，常规药物来说，吸收能力最强的是小肠</li>
<li>药物经细胞吸收进入 静脉-&gt;动脉-&gt;心肺-&gt;动脉-&gt;病灶</li>
<li>药物在上面过程中经过转换成对应病症的化学结构进行化学反应</li>
<li>产生的废料由肝脏代谢，后通过大小便、汗液、乳汁等多种方式排出身体。</li>
</ol>
<p>危害：</p>
<ol>
<li>肝脏、肾脏损害：由于口服药是类似食物，要走消化-吸收-代谢-排泄的流程，而肝脏是专门处理代谢的，肾脏负责处理身体废料的，非食物类的药物会让它们辛苦好几倍。</li>
<li>胃损害：吃激素类、非甾体类（如：消炎、解热镇痛）等药物，会损伤胃粘膜，使保护胃粘膜的前列腺素减少。胃分泌盐酸且能不伤害自己，就需要胃粘膜来保护，没了它就会诱发胃溃疡、胃出血、十二指肠溃疡及出血等症状。</li>
<li>病菌耐药性：假如受了一次流感病毒入侵，通过吃药、吊瓶、针剂等治病症了，<br>　　会有较低概率出现个别病毒在药物作用下为了生存发生异变，从而能在这次吃的药物环境下生存。那么它就在体内生存下来，只是繁衍会受到周边环境的压制。<br>　　如果下次身体再次受到病菌、病毒入侵，身体抗体都去搞新来的病菌、病毒，同时身抵抗力不稳定，这时候那个潜存的变异病毒收到的压制会降低，会趁机大量繁殖，从而产生对应病症。<br>　　而这次在服用它对应的药物，它已经不怕了。这就是自然界的发展的一个基本原理。</li>
</ol>
<p>综合来看，吃药的危害＜肌肉注射的危害＜输液危害</p>
<p>而，最好的治病方法就是：防患于未然！！！</p>
<p>提升身体素质的土方法很多，</p>
<ol>
<li>合理运动、饮食提升身体硬素质。身体强健，耐摔抗打，五脏六腑气息通常，神经、脉搏稳定强健。</li>
<li>培养良好心态、三观，提升身体的软素质。从而接近处事不惊，性情稳定，减少因情绪造成的毒素产生。</li>
</ol>
<p>上面列出的是生活总年龄大了容易遇到的疾病，然而我们努力拼搏大半辈子，到了安养晚年的时候，谁不想平平安安的度过。<br>　　因果循环，今天的选择就是在为明天铺路，是荆棘之路，还是平坦大道，自己的选择决定了大部分。</p>
<p><br><br><br></p>
<p>参考信息： <a href="http://care.39.net/a/121101/4074840.html" target="_blank" rel="noopener">http://care.39.net/a/121101/4074840.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/16/常用疾病治疗方式带来的危害/" data-id="cji413o0l000e08anpvywamn9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hbuilder编辑器误删文件如何恢复" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/12/hbuilder编辑器误删文件如何恢复/" class="article-date">
  <time datetime="2017-06-12T07:01:44.000Z" itemprop="datePublished">2017-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/12/hbuilder编辑器误删文件如何恢复/">hbuilder编辑器误删文件如何恢复</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>废话不说，直接正文：<br>1.假如现在文件目录结构是这样：  </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fgif7flfn0j307k04ut8t.jpg" alt="">  </p>
<p>2.然后删掉charge.html  </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fgif8lodx0j30gg0g0myo.jpg" alt="">  </p>
<p>现在是： </p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fgif9ggv89j309204qaa4.jpg" alt="">  </p>
<p>3.然后双击身份验证文件夹：  </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fgifahk5unj30dy0s0jtr.jpg" alt="">  </p>
<p>4.可以看到菜单里有一个叫做：从本地历史记录复原选项，点击：  </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fgifbp64jqj312q14ywh2.jpg" alt="">  </p>
<p>5.左上角就可以看到所有这个目录里用hbuilder删掉过的文件（前提是这个文件夹的路径没有变动过），选中想回复的，点击恢复后：  </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fgifczdkkoj308k04o3yl.jpg" alt="">  </p>
<p>大功告成！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/12/hbuilder编辑器误删文件如何恢复/" data-id="cji413o06000108anc6ckxzly" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-《神奇女侠》观后感" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/11/《神奇女侠》观后感/" class="article-date">
  <time datetime="2017-06-11T06:55:07.000Z" itemprop="datePublished">2017-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/11/《神奇女侠》观后感/">《神奇女侠》观后感</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><br><br>我喜欢没事看新闻，看的多一点的就是头条、财经、社会 和 一些搞笑的。</p>
<p>不论是从媒体上看到的，还是自己亲身经历过，不难发现：</p>
<blockquote>
<p>与其说有绝对的对错，<br>倒不如说有更合适的做法</p>
</blockquote>
<p>这里也想到网络段子上的一句话：</p>
<blockquote>
<p>不成熟的人讨论对错，<br>成熟的人权衡价值</p>
</blockquote>
<hr>
<p><br><br><br><br>　　《神奇女侠》电影里，女一号，亚马逊公主戴安娜·普林斯，出生在一个只有女性亚马逊人且背负一个神圣使命的种族。从出生的那一刻起，她身上就被负责保护人类正常繁衍的使命：防止人类受到战争之神——阿瑞斯 的蛊惑。<br><br></p>
<pre><code>其实从命运角度来看，
戴安娜也就像是工厂里被造出的一个零件，
她的出现原本就有她的使命，
她唯有履行自己的使命，才能发辉她的价值，
否则就会变成对社会无用的垃圾，
成为世间尘埃或者别人的工具
</code></pre><p>　　<br>　　然而剧情里，由于戴安娜是宙斯与一代亚马逊女王造出的宝贝，所以女王对她很是溺爱。女王是参与过无数战争的人，深知战争的残酷和所能带来的伤痛。所以虽然身为神族后裔的她，像我们的父母一样，希望自己体味过的苦，自己的孩子不要再经历，主动性的希望孩子能过上自己心中所认为的那种美好生活。<a href="#21">（或许这就是人类繁衍本能？让后代以更适合的生存方式去生存）</a><br><br><br>　　所以可想而知，族里所有人都要参与武斗训练，唯有戴安娜，被安排得无所事事。<a href="#21">（感觉我的本性里，就喜欢探索和接触没接触过的、新鲜的，想必这样的性格应该是很多人都有的吧）</a>也正是这样，戴安娜通过自己逃避监视，主动接触，再加上女王妹妹多次强调民族使命，所以戴安娜就开始接触训练，而且是女王为了戴安娜的安全而特殊要求的10倍严格的训练。<br>就这么训练到成年。终于有一天，在与女王妹妹比试的时候，危机时刻爆发了神的力量：护臂力量（可以抵挡、吸收一切世间攻击，并释放回去）。<br><br><br>　　也巧了，当天，戴安娜在海边看到一个人类坠机在海边，救了他同时也付出了代价：抵抗后续追击的敌人，让民族的战士有一定的损伤。<a href="#21">（或许太极的阴阳平衡就是在表达着这混沌世界中的一条规则，无论你做的对与错，都要付出与之相应的代价　或　接受对应的美好。　　每次选择，就像是赌博，自己只要选择自己相信的一注，是好是坏，都必须要接受、承担）</a>也正是与这位男一号史蒂夫的相遇，给自己一个外出拯救人类的机会。从此踏上履行种族使命的不归路……<br><br><br>　　族里一直流传着神族之间的故事，蛊惑人类变得贪婪、自私的正是战争之王阿瑞斯，所以这次出山，戴安娜的第一目标就是要干掉阿瑞斯。<br><br><br>　　如同农村小姑娘进城一样，戴安娜对新世界的一切都充满好奇，在出天堂岛的时候，戴安娜就与史蒂夫相互约定：戴安娜帮助史蒂夫安全的将纳粹科学家的危险武器笔记交给英国军事统领，然后史蒂夫要帮戴安娜找到阿瑞斯。中间经历了一些不澜不惊的起伏。终于在纳粹的鸿门宴舞会上遇到了阿瑞斯。<br><br><br>　　戴安娜只能凭借自己的个人主观判断，来从众人中分辨出那个是乔装的阿瑞斯。也正式自己第一次做这样的事情，又没有专业工具的帮忙，她错杀了一位人类军官。<a href="#21">（走在社会前沿，为代表人类前进的科学家、各种家们，也只能凭着自己的个人思想&amp;个人推断来探索。　　然而身为普通人的我们，我认为多一点请教、多一点查询，完全可以避免生活中的很多很多错误，从而加快自己人生的节奏，让自己更快的达到自己的人生目标）</a></p>
<p>  <br><br>  与漫威电影一样，DC这里的结局就是：正义战胜邪恶，没有为什么的，就是一记大宝剑撸过去，OVER！  然而在戴安娜战斗的同时，观念一致的史蒂夫掠夺了运输毒药炸弹的飞机，在高空引爆，点燃自己生命的烟火~ 也正是他的牺牲，让戴安娜第一次感受到身边人的离去，原来是自己根本无法控制的，让戴安娜深受刺激，进一步爆发了神之力量，一击KO阿瑞斯。<br>  <br><br><br>　　剧末，经历了这段风雨的戴安娜说：<br>  <br><br></p>
<blockquote>
<p>过去我总想拯救世界<br>结束战争并把和平带给人类<br>但后来我看到了光明之中的黑暗<br>并知道在每个人心中<br>善与恶永远并存</p>
<p>因此每个人都要做出抉择<br>这是任何英雄都无法代劳的</p>
<p>现在我知道了<br>只有爱才能拯救这个世界<br>所以 我留下 我战斗 我给予<br>为了这个世界</p>
<p>谢谢你把史蒂夫给我，<br>这就是我的使命，<br>永远的~</p>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fgha4rf0qqj309908caap.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/11/《神奇女侠》观后感/" data-id="cji413o06000308anhuo3j9ke" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第一次webpack使用流程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/01/第一次webpack使用流程/" class="article-date">
  <time datetime="2017-06-01T10:06:58.000Z" itemprop="datePublished">2017-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/01/第一次webpack使用流程/">第一次webpack使用流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="开发环境下"><a href="#开发环境下" class="headerlink" title="开发环境下"></a>开发环境下</h3><ol>
<li>nodeJS（提供ES6）环境下</li>
<li>用npm init 生成package.json用于配置依赖包信息</li>
<li>创建两个文件夹After Before，一个用于存放自己编写代码，一个用于webpack生成文件的存放</li>
<li>webpack执行是根据一个入口文件进行压缩配置，在输出到一个出口文件里，所以在Before文件夹下创建一个main.js作为入口文件；所有需要输出的代码最终都要引入到这个文件中 import React from ‘React’; import ‘./main.css’;</li>
<li>根据实际开发需求，渐进式的安装所需的依赖包，例如：npm install json-loader –save；npm install css-loader, style-loader –save；逐步通过保存本地式(–save)安装的依赖包会被自动添加到package.json中</li>
<li>开发结束，需要生成最终文件，执行npm webpack将文件合并生成到After文件夹中的指定文件</li>
<li>在After文件夹中创建index.html文件，并引入最终生成的js文件即可；After下的文件即为最终文件</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/01/第一次webpack使用流程/" data-id="cji413o0l000i08ankvqpgsf2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-用nodeJS批量处理html文件的公共部分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/01/用nodeJS批量处理html文件的公共部分/" class="article-date">
  <time datetime="2017-06-01T10:06:15.000Z" itemprop="datePublished">2017-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/01/用nodeJS批量处理html文件的公共部分/">用nodeJS批量处理html文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><br></p>
<p>最近接手一个任务，给一个集团写一个静态站点，看了设计稿发现除了首页，其他页面的头部nav和底部footer都是一样的。如果写好粘贴赋值粘贴复制，多累啊！————于是想到一个需求：</p>
<p><br><br><br>  </p>
<blockquote>
<p>如何能让页面公用部分写一边，然后所有页面都能同步？  </p>
</blockquote>
<p><br><br>作为前端出身，技术栈又比较少~ 第一个想到的就是nodeJS了！毕竟JS是前端特有唯一一门编程语言了！</p>
<hr>
<p><br><br><br><br>首先，屡屡思路：<br><br><br><br>  </p>
<ol>
<li>目的是：公用部分单独写一份，然后页面只需要写除了公用部分之外的即可。</li>
<li>前提是：如果出现异常，不能影响自己写的代码-&gt;所以要另外建立一个文件夹，用于存放node处理后的代码</li>
</ol>
<p><br><br><br>  </p>
<p>接下来，开始node编写：  </p>
<p><strong>section 1</strong><br><br><br>一、 首先在新建文件夹下创建两个文件夹：  </p>
<blockquote>
<p>app（写代码的地方）<br>public（生成代码的地方）<br>handile.js（nodeJS文件）</p>
</blockquote>
<p>目录结构如下：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fg886inyhzj30am03uq32.jpg" alt=""></p>
<p><br><br><br>  </p>
<p>二、 做到将app里的文件复制到public中<br>　　解析功能<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制文件用到node的fs模块，用到readFile,writeFile功能，然而如果用这两个语法，它的原理是将文件内容读取保存在内存中，然后再一次性写入一个文件</span></span><br><span class="line"><span class="comment">//想想，这样就会遇到一个问题：如果文件比较大，一次性读取和写入，会不会很吃内存。</span></span><br><span class="line"><span class="comment">//就像是这里要从水龙头取水，将旁边一个无法移动的大缸接满，如果选择一次性接一缸水，再倒到水缸里，这显然是不明智的</span></span><br><span class="line"><span class="comment">//考虑这一点，这里要用Stream流信息处理方式，就是读着写着，像有水管一样，上面流着，下面接着，这样可行性就更高了,代码如下：</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">origin, aim</span>) </span>&#123;</span><br><span class="line">	fs.createReadStream(origin).pipe(fs.createWriteStream(aim));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里pipe方法就是这里举例中的水管</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>　　现在有了一个能连通数据流的水管了，这里要将水管入口接到水龙头上，出口接到大缸里  </p>
<p><br><br><br><br>　　但现在这里还遇到一个问题，app文件夹下是可能会有img css js等文件夹的，而这里的方法createReadStream只能读取指定的一个文件，<br><br><br><br>  </p>
<p> <strong>所以这里要有一个遍历app和hbuild目录的方法，把app目录里所有文件的路径遍历出来，给copy方法的origin参数，再将app目录里文件的路径名字中app替换为hbuild，传给copy方法的aim参数，这样如果app文件夹下有多个文件，就相当于这里创造了多条水管，每个水管只负责一个文件信息流的传输</strong></p>
<p><br><br>这里要用到readdir方法，这里选择同步读取，保证开水龙头，水管传输，水进入水缸的正确顺序，这样就不用promise来单独处理异步了。所以这里用readdirSync方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">	fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> pathname = path.join(dir, file); <span class="comment">//将遍历到文件的路径给变量pathname</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(fs.statSync(pathname).isDirectory()) &#123;<span class="comment">//判断是当前遍历到的文件是否是一个文件夹，如果是则进入文件夹再进行遍历：</span></span><br><span class="line">			travelSync(pathname, callback);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			callback(pathname);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<p>这样一个tranvel函数，需要两个参数，遍历的目录路径，和回调函数<br>这样这里就可以组合两个函数进行遍历和写入　　<br><br></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">travelSync(<span class="string">'./app'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pathname) &#123;</span><br><span class="line">		<span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>)</span><br><span class="line">			copy(pathname, publicPath);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelSync</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">	fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> pathname = path.join(dir, file);</span><br><span class="line">		<span class="built_in">console</span>.log(pathname)</span><br><span class="line">		<span class="keyword">if</span>(fs.statSync(pathname).isDirectory()) &#123;</span><br><span class="line">			travelSync(pathname, callback);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			callback(pathname);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件复制成功！'</span>)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dst</span>) </span>&#123;</span><br><span class="line">	fs.createReadStream(src).pipe(fs.createWriteStream(dst));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>这里在app文件夹里新建几个目录和文件来做测试<br><br><br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fghckwi0p5j307m0b8dg9.jpg" alt=""></p>
<p>header index footer 三个html文件里分别写：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- header.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">this is header!</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">this is index.html</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- footer.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">this is footer!</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><br><br>然后在终端 cmd， 进入当前文件夹路径，执行 node handle.js　　<br><br><br><br></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fghcoh0xv5j306400s748.jpg" alt=""></p>
<p><br></p>
<p>然后再打开public文件夹，看下，发现：</p>
<p><br></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fghcp1s4bmj30hs036dg5.jpg" alt=""></p>
<p>哎！what？ 为什么css img js文件夹和里面的文件没有复制过来？<br><br><br>这是因为这里在遍历目录的时候，copy方法只实现了文件流信息的传输，但没有实现文件夹创建功能，所以这样运行会出现报错：<br><br><br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fgi61eege0j30ri024wev.jpg" alt=""></p>
<p><br></p>
<p>那么接下来就要写cipyDir方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyDir</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">	fs.mkdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123; <span class="comment">//mkdir方法创建文件夹只需要通过第一个参数告诉node路径和文件夹名即可创建，简单暴力</span></span><br><span class="line">		<span class="keyword">if</span>(!err) <span class="built_in">console</span>.log(path+<span class="string">' 目录创建成功!'</span>)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里这里要修改一下travel方法，当travel遍历到文件夹的时候，在build文件夹下执行创建文件夹命令： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelSync</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">	fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> pathname = path.join(dir, file);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(fs.statSync(pathname).isDirectory()) &#123;</span><br><span class="line">			callback(pathname,<span class="string">'dir'</span>); <span class="comment">//新增：遇到文件夹也执行回调，并传入一个字符串用于告知回调函数知道这是一个文件夹的pathname</span></span><br><span class="line">			travelSync(pathname, callback);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			callback(pathname,<span class="string">'file'</span>);<span class="comment">//这里也添加告知回调函数文件类型的第二个参数'file'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来撸一遍现在的handle.js，是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">travelSync(<span class="string">'./app'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">pathname, fileType</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pathname &amp;&amp; fileType === <span class="string">'file'</span>) &#123;</span><br><span class="line">		<span class="comment">// app/header.html</span></span><br><span class="line">		<span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>);</span><br><span class="line">		copy(pathname, publicPath);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname &amp;&amp; fileType === <span class="string">'dir'</span>) &#123;</span><br><span class="line">		<span class="comment">// app/css</span></span><br><span class="line">		<span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>);</span><br><span class="line">		copyDir(publicPath)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelSync</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">	fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> pathname = path.join(dir, file);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(fs.statSync(pathname).isDirectory()) &#123;</span><br><span class="line">			callback(pathname,<span class="string">'dir'</span>);</span><br><span class="line">			travelSync(pathname, callback);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			callback(pathname,<span class="string">'file'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">path, aimPath</span>) </span>&#123;</span><br><span class="line">	fs.createReadStream(path).pipe(fs.createWriteStream(aimPath));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyDir</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">	fs.mkdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!err) <span class="built_in">console</span>.log(path+<span class="string">' 目录创建成功!'</span>)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok,现在再测试下复制功能是否能解决刚才无法复制文件夹的问题：命令行运行：node handle.js，打印出：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fgi809xc8lj30fo046mxx.jpg" alt=""></p>
<p>再看public文件夹目录：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fgi812xiskj30bq0dcmxr.jpg" alt=""></p>
<p>漂亮！现在复制功能已经达到。敲代码的，就是需要做好铺垫，才能快速行动~ 接下来进入关键时刻，处理文件的公用部分</p>
<hr>
<p><strong>section 2</strong></p>
<p><br></p>
<p>这里模拟测试将app里的header footer 整合到index.html的 头 和 尾。 现在要用到readFile 和 writeFile语法，读取header footer里指定的内容，再写入index指定位置。</p>
<p><br></p>
<p>这里先想一个问题：如果文件比较大，内容比较复杂，如何才能准确的找到header footer里面指定的代码段， 然后准确的写入index指定的位置？先别看下面解决方案，两分钟，看自己能想出哪些方法</p>
<p><br><br><br><br><br><br><br><br><br><br>我暂想到相对好用的方法是：</p>
<ol>
<li>在header footer文件需要截取的代码段头尾添加一个标记行注释标签，同样，在index里面也放一个注释标签，告诉handle.js准确位置</li>
</ol>
<p>也有一个不好用的：就是直接判断代码段开始标签，和结束标签，这样每次都要严格查询代码并做更改，其实挺麻烦的。</p>
<p><br><br>这里修改header  index  footer，添加标记注释，分别更改为：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- header begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">	this is header!</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- header end --&gt;</span></span><br><span class="line">```  </span><br><span class="line">```html</span><br><span class="line"><span class="comment">&lt;!-- index begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">	this is index.html</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- index end --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- footer begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">	this is footer!</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- footer end --&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来在heandle.js里写header footer代码段截取功能，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHeader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	fs.readFile(<span class="string">'./app/header.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> headerData = html.toString();</span><br><span class="line">		<span class="comment">// sliceStart只需要找到字符串的索引位置即可</span></span><br><span class="line">		<span class="keyword">var</span> sliceStart = headerData.indexOf(<span class="string">'&lt;!-- header begin --&gt;'</span>);</span><br><span class="line">		<span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span></span><br><span class="line">		<span class="keyword">var</span> sliceEnd = headerData.indexOf(<span class="string">'&lt;!-- header end --&gt;'</span>) + <span class="string">'&lt;!-- header end --&gt;'</span>.length+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">var</span> header = headerData.slice(sliceStart, sliceEnd);</span><br><span class="line">		<span class="built_in">console</span>.log(header)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">getHeader();</span><br></pre></td></tr></table></figure>
<p>命令行运行node handle.js后 看到：  </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fgi9i75b9yj30hg04idge.jpg" alt="">   </p>
<p>这样就准确找到想要的代码段了。<br>由于还需要用同样的方法找到index和footer代码段，所以这里将getHeader方法封装成一个getAimCode方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAimCode</span>(<span class="params">headerPath, flagBegin, flagEnd</span>) </span>&#123;</span><br><span class="line">  fs.readFile(headerPath, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">      <span class="keyword">var</span> headerData = html.toString();</span><br><span class="line">      <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span></span><br><span class="line">      <span class="keyword">var</span> sliceStart = headerData.indexOf(flagBegin);</span><br><span class="line">      <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span></span><br><span class="line">      <span class="keyword">var</span> sliceEnd = headerData.indexOf(flagEnd) + flagEnd.length+<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">var</span> header = headerData.slice(sliceStart, sliceEnd);</span><br><span class="line">      <span class="built_in">console</span>.log(header)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试以下用getAimCode获取footer代码段</span></span><br><span class="line">getAimCode(<span class="string">'./app/footer.html'</span>, <span class="string">'&lt;!-- footer begin --&gt;'</span>, <span class="string">'&lt;!-- footer end --&gt;'</span>);</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">封装函数最笨的办法：把可能会变动的内容，替换成参数变量，再通过函数调用，以参数的形式传进去，可以运行下上面代码，即可得到footer代码段，测试上面代码即可得到：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![](https://ws2.sinaimg.cn/large/006tKfTcly1fi7iyyrgl8j308i03ujrn.jpg)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">现在能找到需要截取的代码段，接下来要进行代码段的准确插入：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">其实插入代码段的基础原理，就是将目标文件信息读取出来，分为三段：</span></span><br><span class="line"><span class="string">1. 插入位置之前的代码段 top</span></span><br><span class="line"><span class="string">2. 插入header和footer之间的代码段 content </span></span><br><span class="line"><span class="string">3. 插入footer之后的代码段 bottom</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后只需要将代码段拼接成 top + header + content + footer + bottom 这么一个完整的代码块，再写入目标文件就完成了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">接下来对目标文件index进行分割：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为了明显看出index的分割效果，这里将index.html更改内容为：</span></span><br><span class="line"><span class="string"> `</span><span class="string">``</span>html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;title&gt;index&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- index begin --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">	<span class="keyword">this</span> is index.html</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- index end --&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br><span class="line"> <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">回想下，从header.html中切出header代码段的时候，是找到</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>html</span><br><span class="line">&lt;!-- header begin --&gt;</span><br><span class="line">和</span><br><span class="line">&lt;!-- header end --&gt;</span><br></pre></td></tr></table></figure>
<p>两个标记的索引位置，用String.slice(start,end)方法来切割的。那么index的三段一样要找到top content bottom三者的开始位置和结束位置。这里先默认index文件的内容被读取为：indexData，那么：</p>
<pre><code class="html">1. top：是从文档的开始，开始位置就是索引值0，
2. 结束索引值就是index begin标记的开始，即indexData.indexOf('<span class="comment">&lt;!-- index begin --&gt;</span>');

3. content：开始索引值是indexData.indexOf('<span class="comment">&lt;!-- index begin --&gt;</span>');
4. 结束索引值是：indexData.indexOf('<span class="comment">&lt;!-- index end --&gt;</span>')+'<span class="comment">&lt;!-- index end --&gt;</span>'.length+2;

5. bottom：开始索引值是indexData.indexOf('<span class="comment">&lt;!-- index end --&gt;</span>')+'<span class="comment">&lt;!-- index end --&gt;</span>'.length+2,
6. bottom可以直接切到文档结尾，slice方法如果不传入第二个参数的话就默认直接从指定索引位置切割到结尾
</code></pre>
<p>这样就可以写出函数：</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">cutIndex</span>(<span class="params"></span>) </span>{
  fs.readFile(<span class="string">'./app/index.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>{
    <span class="keyword">if</span>(!err) {
      <span class="keyword">var</span> indexData = html.toString();
      <span class="keyword">var</span> topStart = <span class="number">0</span>,
        topEnd = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>);
      <span class="keyword">var</span> contentStart = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>),
        contentEnd = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;
      <span class="keyword">var</span> bottomStart = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;

      <span class="keyword">var</span> top = indexData.slice(topStart, topEnd),
        content = indexData.slice(contentStart, contentEnd),
        bottom = indexData.slice(bottomStart);
      <span class="built_in">console</span>.log(top+<span class="string">'top打印结束'</span>);
      <span class="built_in">console</span>.log(content+<span class="string">'content打印结束'</span>);
      <span class="built_in">console</span>.log(bottom+<span class="string">'\n bottom打印结束'</span>);
    }
  })
}
cutIndex();
</code></pre>
<p>命令行里执行：node handle.js<br>打印出：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fgirvxjl9xj30gg0ayq3y.jpg" alt="">  </p>
<p>现在得到了header footer top content bottom，接下来要做拼接并的功能。  </p>
<p>将我们的代码组装起来成为：</p>
<pre><code class="javascript">fs.readFile(<span class="string">'./app/header.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>{
    <span class="keyword">if</span>(!err) {
        <span class="keyword">var</span> headerData = html.toString();
        <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span>
        <span class="keyword">var</span> sliceStart = headerData.indexOf(<span class="string">'&lt;!-- header begin --&gt;'</span>);
        <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span>
        <span class="keyword">var</span> sliceEnd = headerData.indexOf(<span class="string">'&lt;!-- header end --&gt;'</span>) + <span class="string">'&lt;!-- header end --&gt;'</span>.length+<span class="number">2</span>;
        <span class="keyword">var</span> header = headerData.slice(sliceStart, sliceEnd);
    }

    fs.readFile(<span class="string">'./app/footer.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>{
        <span class="keyword">if</span>(!err) {
            <span class="keyword">var</span> footerData = html.toString();
            <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span>
            <span class="keyword">var</span> sliceStart = footerData.indexOf(<span class="string">'&lt;!-- footer begin --&gt;'</span>);
            <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span>
            <span class="keyword">var</span> sliceEnd = footerData.indexOf(<span class="string">'&lt;!-- footer end --&gt;'</span>) + <span class="string">'&lt;!-- footer end --&gt;'</span>.length+<span class="number">2</span>;
            <span class="keyword">var</span> footer = footerData.slice(sliceStart, sliceEnd);
        }

        fs.readFile(<span class="string">'./app/index.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>{
            <span class="keyword">if</span>(!err) {
                <span class="keyword">var</span> indexData = html.toString();
                <span class="keyword">var</span> topStart = <span class="number">0</span>,
                    topEnd = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>);
                <span class="keyword">var</span> contentStart = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>),
                    contentEnd = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;
                <span class="keyword">var</span> bottomStart = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;

                <span class="keyword">var</span> top = indexData.slice(topStart, topEnd),
                    content = indexData.slice(contentStart, contentEnd),
                    bottom = indexData.slice(bottomStart);
            }
            <span class="built_in">console</span>.log(top+header+content+footer+bottom);
        })
    })
})
</code></pre>
<p>执行代码就可以得到：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fgit2euk34j30je0gedhu.jpg" alt="">  </p>
<p>最终，结合section1，handle.js要完成：</p>
<ol>
<li>先将app文件夹的目录结构复制到public文佳夹下</li>
<li>对文件切割完毕，重组合，再写入public文件夹下的index.html中</li>
</ol>
<p>基础版最终代码如下：</p>
<pre><code class="javascript">travelSync(<span class="string">'./app'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">pathname, fileType</span>) </span>{
    <span class="keyword">if</span>(pathname &amp;&amp; fileType === <span class="string">'file'</span>) {
        <span class="comment">// app/header.html</span>
        <span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>);
        copy(pathname, publicPath);
    } <span class="keyword">else</span> <span class="keyword">if</span> (pathname &amp;&amp; fileType === <span class="string">'dir'</span>) {
        <span class="comment">// app/css</span>
        <span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>);
        copyDir(publicPath)
    }

    fs.readFile(<span class="string">'./app/header.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>{
        <span class="keyword">if</span>(!err) {
            <span class="keyword">var</span> headerData = html.toString();
            <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span>
            <span class="keyword">var</span> sliceStart = headerData.indexOf(<span class="string">'&lt;!-- header begin --&gt;'</span>);
            <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span>
            <span class="keyword">var</span> sliceEnd = headerData.indexOf(<span class="string">'&lt;!-- header end --&gt;'</span>) + <span class="string">'&lt;!-- header end --&gt;'</span>.length+<span class="number">2</span>;
            <span class="keyword">var</span> header = headerData.slice(sliceStart, sliceEnd);
        }

        fs.readFile(<span class="string">'./app/footer.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>{
            <span class="keyword">if</span>(!err) {
                <span class="keyword">var</span> footerData = html.toString();
                <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span>
                <span class="keyword">var</span> sliceStart = footerData.indexOf(<span class="string">'&lt;!-- footer begin --&gt;'</span>);
                <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span>
                <span class="keyword">var</span> sliceEnd = footerData.indexOf(<span class="string">'&lt;!-- footer end --&gt;'</span>) + <span class="string">'&lt;!-- footer end --&gt;'</span>.length+<span class="number">2</span>;
                <span class="keyword">var</span> footer = footerData.slice(sliceStart, sliceEnd);
            }

            fs.readFile(<span class="string">'./app/index.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>{
                <span class="keyword">if</span>(!err) {
                    <span class="keyword">var</span> indexData = html.toString();
                    <span class="keyword">var</span> topStart = <span class="number">0</span>,
                        topEnd = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>);
                    <span class="keyword">var</span> contentStart = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>),
                        contentEnd = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;
                    <span class="keyword">var</span> bottomStart = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;

                    <span class="keyword">var</span> top = indexData.slice(topStart, topEnd),
                        content = indexData.slice(contentStart, contentEnd),
                        bottom = indexData.slice(bottomStart);
                }
                <span class="keyword">var</span> indexChunk = top+header+content+footer+bottom;
                fs.writeFile(<span class="string">'./public/index.html'</span>, indexChunk, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
                    <span class="keyword">if</span>(!err) <span class="built_in">console</span>.log(<span class="string">'文件处理成功！'</span>)
                })
            })
        })
    })
})
</code></pre>
<p>再次在命令行里执行：node handle.js<br>终端输出：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fgitccgnncj30bo06agma.jpg" alt="">  </p>
<p>再打开public/index.html，就变成了：  </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fgitd3zlxzj30ie0l4tau.jpg" alt="">  </p>
<p>这里node命令是异步处理，所以出现代码嵌套非常多，稍微改动就成了传说中的回调地狱~   </p>
<p>后续更新promise优化版。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/01/用nodeJS批量处理html文件的公共部分/" data-id="cji413o0l000k08anphnapc11" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-我的胃出血" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/30/我的胃出血/" class="article-date">
  <time datetime="2017-05-30T02:42:37.000Z" itemprop="datePublished">2017-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/30/我的胃出血/">我的胃出血</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从上周一发烧，周二吊瓶治好后，周三开始出现大便黑亮（胃出血的征兆），当晚下班就门诊，医师给了一瓶奥美拉唑，效果很好周四就恢复正常了。  </p>
<p>但周五觉着ok了，就没再吃，周六又复发了ヽ(`Д´)ﾉ<br>无奈，只能继续服药。今天就搜搜总结下这次的胃出血。  </p>
<p>环境：  </p>
<ol start="0">
<li>4年前犯过急性胃炎，住院两天；两年前复发一次，就医及时，一次吊瓶解决。</li>
<li>日常我都会两天去一次健身房游泳（可能会对未修复的胃及十二指肠造成拉伸伤害），</li>
<li>上周一发烧，当晚一夜翻来覆去，中间不断难受至醒，睡眠效率极差（也是从这里开始，胃出血发生），</li>
<li><ol>
<li>周一发烧后，</li>
<li>周二吊瓶退烧，</li>
<li>周三晚上开始服用奥美拉唑，</li>
<li>周五晚上停用且去游泳（因为周四大便色已经恢复了），</li>
<li>周六开始喉咙和上支气管开始发炎（可能和泳池水不卫生有关系，每次游泳结束要刷牙）</li>
<li>周日去门诊咨询发炎问题，医师说非两天吊瓶不能治好（当时觉着：一是太依赖大量给药，让自己身体都自身修复功能都废了；二是当时觉着没这么夸张吧，怀疑是为了挣钱；），然后就开两天肌肉注射小针，一盒惠州的清热散结片-消炎中药，一盒莎普爱思药业的头孢克污分散片-抗菌西药。</li>
<li>第二个周一胃出血复发，开始继续每天两次服用奥美拉唑。</li>
<li>现在第二个周二了，针对咽喉问题服药有满2天了，发炎症状仍未褪去；</li>
</ol>
</li>
</ol>
<p>这就很尴尬了，原本想着能在治好病的前提下，最低化给药，现在不清楚是复发还是根本没治愈，病症一直持续着。  </p>
<p>接下来就开始度之，胃出血：</p>
<blockquote>
<p>原因：</p>
<p>1 首先是40%以上的可能性先患了胃溃疡</p>
<p>-1.1 偏食挑食、饥饱失度、饮食过冷过热、吃辣、浓茶、咖啡等刺激，引起肠胃消化功能紊乱，胃液分泌失衡，引起溃疡<br>-1.2 遗传因素<br>-1.3 病菌感染，常见的幽门螺杆菌<br>-1.4 精神紧张、多愁善感、脑力劳动过多<br>-1.5 长期饮酒、吸烟、长期复用阿司匹林等非甾体抗炎药，刺激胃粘膜导致溃疡  </p>
<p>2 进酒刺激胃血管扩张充血以至破裂</p>
<p>3 进食不易消化菜肴或刺激食品，</p>
<p>4 近期生气过、或情绪波动较大</p>
<p>5 腹部受撞击、剧烈运动或奔波劳顿</p>
<p>症状：</p>
<p> 1 呕血：若出血立即呕出血液为鲜红色；若血液在胃里停留一段时间再呕出，血液呈咖啡渣样子的棕褐色。</p>
<p> 2 柏油样黑便：这种情况占比更高，血红蛋白在肠内硫化物的作用下生成黑色硫化铁，所以产生柏油亮的黑色。若排除血液是暗红色或者鲜红色，说明出血量较大或很大，一般伴有呕血。若出血部位在十二指肠，呕血概率较低。</p>
<p> 3 若出血速度慢，量少，一般无全身症状，仅在长期出血后出现贫血。若出血速度快且量多，则可能出现心慌、冷汗、面色苍白，甚至血压下降等急性失血症状。</p>
<p>治疗：</p>
<p>1 疗程：根据症状不同，一般1-4周时间，溃疡才会修复。</p>
<p>2 药物：轻微症状常用对症药物：奥美拉唑等；<br>3 注意事项：</p>
<p>-3.1 饮食定时定量，禁止饱饥失度；<br>-3.2 禁烟酒及过酸、过硬等会对肠胃造成损伤的食物；<br>-3.3 禁用对胃粘膜有损害的药物，如激素类、水杨酸类、消炎痛、红霉素、利血平等（在有胃粘膜保护剂的环境下可以用）；<br>-3.4 预防贫血，多吃高铁量食物，如菠菜、猪肝、蛋黄等，严重者可以药补；<br>-3.5 保持情绪平稳、愉快；<br>-3.6 避免熬夜、过度劳累<br>-3.7 防寒保暖</p>
</blockquote>
<p>啊~ 总结了这一堆，发现自己确实犯了以上部分禁忌：</p>
<ol>
<li>剧烈运动导致肌肉拉伸造成伤害</li>
<li>尽量两天玩王者荣耀，被连着匹配挂机或送头的，气愤情绪持续有1小时</li>
<li>昨天吃红薯叶，商家卖的红薯杆粗而硬</li>
<li>做饭放辣椒，贪念口感</li>
<li>奥美拉唑服用中间断服两天</li>
</ol>
<p>哎~ 这样想想，自己的病症褪去延缓和病症复发，自作的影响也不少啊~<br>这样清晰的罗列出来后，能很明确的知道自己该做什么，有哪几条，日后每天再针对这几条做的不好的进行自我反省，有没有做到。<br>相信，这周内，调整好自我状态，再将剩下的药物服用完，一定会好起来！(｀･ω･´)  </p>
<p>困难挑战者！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/30/我的胃出血/" data-id="cji413o0l000d08anmkn531ia" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-不同炎症种类，不同用药" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/28/不同炎症种类，不同用药/" class="article-date">
  <time datetime="2017-05-28T02:54:17.000Z" itemprop="datePublished">2017-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/28/不同炎症种类，不同用药/">不同炎症种类，不同用药</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本周一本市急剧降温，一下子降温15℃，一向怕冷的我，下班出了大厦，没多久就感觉冷的发抖。   </p>
<p>20+20分钟到家。word哥！刚到家坐下就感觉发烧了（小时候经常烧，现在很轻易就辨别出什么是发烧(不是感冒)）：</p>
<blockquote>
<p>1 发烧的时候血液成分已经根据体温不同而有不同程度的紊乱，感觉全身皮肤神经过敏似的，全身任何部位都会随机随时出现神经疼。感觉身体不是自己的，肌肉都起来变得费力了。</p>
<p>2 头发蒙，甚至头疼，更甚至会出现晕厥、嗜睡。</p>
</blockquote>
<p>凭着我个人的一种理念：享受成长的过程。 </p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fg0wzkkz05j30xg0gctcs.jpg" alt=""></p>
<p>于是选择按照老一辈的解决方法：出出汗，闷一晚上就会好了。这是针对<mark>风寒感冒</mark>的一种疗法；</p>
<blockquote>
<p>身体瘦了风寒，皮肤不能正常疏泻体内热量，导致身体温控系统出现问题。</p>
<p>所以通过药物、事物、运动等方法使身体发热，将皮肤过于缩紧的毛孔舒张，回复体温调节功能，人身体功能恢复，感冒就好了。</p>
<p>但对于风热感冒不可用，否则身体会发虚，体液过度蒸发导致体液减少，新陈代谢困难，甚至危及生命。风热感冒一般要去火，多喝温开水。<br><a href="https://zhidao.baidu.com/question/82065934.html?qbl=relate_question_2&amp;word=%CE%AA%CA%B2%C3%B4%B7%A2%C9%D5%B3%F6%B3%F6%BA%B9%CB%AF%D2%BB%CD%ED%C9%CF%BE%CD%BB%E1%BA%C3%B5%E3" target="_blank" rel="noopener">https://zhidao.baidu.com/question/82065934.html?qbl=relate_question_2&amp;word=%CE%AA%CA%B2%C3%B4%B7%A2%C9%D5%B3%F6%B3%F6%BA%B9%CB%AF%D2%BB%CD%ED%C9%CF%BE%CD%BB%E1%BA%C3%B5%E3</a></p>
</blockquote>
<p>然后我就到楼梯道做了300个上下阶梯动作，身体微微出汗，回来吃完饭，喝水就捂着。<br><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fg0x11aiuij30ty0t0n0f.jpg" alt=""></p>
<p>但郁闷的是，愣是一晚上没睡着，全身神经感觉刺激得不能入睡，翻来覆去整了一晚上。。。第二天各种疲惫。  </p>
<p>无奈，请假，吊瓶~（这里如果时间不紧急的话，建议选择有把握的低伤害疗法：药物&gt;小针&gt;吊瓶&gt;手术&gt;化疗）  </p>
<p>鉴于三年时间终于有一次发烧，刚好今天休息，百度百度就写下这么一个总结，将来再次翻阅可以节约时间。</p>
<hr>
<p>接下来说说用药：</p>
<h4 id="消炎药-vs-抗菌杀毒药物"><a href="#消炎药-vs-抗菌杀毒药物" class="headerlink" title="消炎药 vs 抗菌杀毒药物"></a>消炎药 vs 抗菌杀毒药物</h4><p>这不少人都会有知识倾斜：觉着哪里发炎就买哪里的消炎药就好了。 -那么就来看看消炎药在我们体内都做了什么。  </p>
<p>这里贴上白加黑说明书中的一段：</p>
<blockquote>
<p>【药理作用】 白加黑中对乙酰氨基酚可抑制前列腺素合成而具有解热镇痛作用;盐酸伪麻黄碱具有收缩上呼吸道毛细血管、消除鼻咽黏膜充血、减轻鼻塞、流涕的作用;氢溴酸右美沙芬能抑制咳嗽中枢，具有止咳作用;盐酸苯海拉明为抗组胺药，能进一步减轻鼻塞、流涕、打喷嚏等症状，并有镇静安眠的作用。</p>
</blockquote>
<p>这里看清楚了，这里消炎药将我们身体外层不舒服的各种症状平复了，那么这里提一个关键问题：</p>
<h5 id="病治好了吗？"><a href="#病治好了吗？" class="headerlink" title="病治好了吗？"></a>病治好了吗？</h5><p>来回头想想：是什么原因导致我们感冒发烧的？</p>
<ol>
<li>病毒性感冒-&gt;多为流行感冒性病毒（流感病毒）入侵（身体保卫成员第一道防线防御失败，第二第三道防线开始对抗外来病毒的时候，在双方战场上布下更优于自己的环境，而产生炎症区域。）</li>
<li>细菌性感冒-&gt;细菌入侵身体（同上，内外双方的战场就是我们的炎症区域）  </li>
</ol>
<p>人体三道防线链接：<a href="http://baike.baidu.com/link?url=Hj5fBvvaegSi7K_pLmFCjicKhdFMJoSyS1xgL6ZR0jg0dchiTlYfQFwv4oVLaQpk9hpaRWCMiZ4axDu62fsw1tXDUEcOEOmCLyA6BavZd_63PQSWfZYeWVUonzPgPf0bmjZmtrJXW6fREDAV3s0GmK" target="_blank" rel="noopener">http://baike.baidu.com/link?url=Hj5fBvvaegSi7K_pLmFCjicKhdFMJoSyS1xgL6ZR0jg0dchiTlYfQFwv4oVLaQpk9hpaRWCMiZ4axDu62fsw1tXDUEcOEOmCLyA6BavZd_63PQSWfZYeWVUonzPgPf0bmjZmtrJXW6fREDAV3s0GmK</a>  </p>
<p>这么来看，我们用消炎药消除的其实是 有利于身体保卫成员作战的战场。就好像本来我们手里拿着武器跟敌人对打，突然武器没了，赤手面对敌人，是不是压力更大了呢？</p>
<p>而且这个时候，不少人都觉着：恩，病治好啦！</p>
<p>然而实际上战争还在继续，只是不影响我们正常状态了而已……为我们的包围着默哀一会儿~</p>
<h5 id="然而为什么医师开药，也会先来上两盒消炎药呢？"><a href="#然而为什么医师开药，也会先来上两盒消炎药呢？" class="headerlink" title="然而为什么医师开药，也会先来上两盒消炎药呢？"></a>然而为什么医师开药，也会先来上两盒消炎药呢？</h5><p>这里实际上医师往往开药的成分里带有杀菌或者杀毒的药物了，而我们只看到了表面：消炎药！就你！  </p>
<p>所以这里建议用药的朋友们没事儿可以看看说明书里的药理病理慢慢的，就能把我们的知识倾斜纠正过来，也会理解一些良心医师为什么多开一些“所谓用不上”药了。更是让自己成长一步，强大一点，</p>
<hr>
<p>最近游泳很有进步：可以一口气游50米。ヾ(=^▽^=)ノ</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/28/不同炎症种类，不同用药/" data-id="cji413o06000708anonwb6259" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-通过url参数控制页面" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/27/通过url参数控制页面/" class="article-date">
  <time datetime="2017-05-27T07:08:38.000Z" itemprop="datePublished">2017-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/27/通过url参数控制页面/">通过url参数控制页面</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天写一个静态站的时候，遇到一个问题：站点页面之间可以通过a链接相互跳转，但是nav里有部分导航直接导航到页面的某个位置，甚至根据多个导航指向一个页面的不同功能区。</p>
<p>应用场景：用户只是点击了nav的一个链接，希望打开页面就能看到自己想看到的，不希望在打开页面后再进行其他操作才能到达目的地。</p>
<p>这样的话，就需要在页面加载完毕的时候就已经是用户想要的画面。于是想到一个办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接在a链接里href上带上约定参数param，然后在打开页面的时候js获取这个参数，根据参数不同执行不同的内容即可</span><br></pre></td></tr></table></figure>
<p>这里就在html里写</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"pagename=dynamic"</span>&gt;</span>内容内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>javascript里：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = location.href;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sliceStart = url.indexOf(<span class="string">'pagname'</span>);</span><br><span class="line"><span class="keyword">var</span> pagename = url.slice(sliceStart); <span class="comment">//pagename=dynamic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里考虑到如果后台嵌入的时候可能会在url里嵌入其他参数，所以要做以下处理</span></span><br><span class="line"><span class="comment">//首先url里多参数的形式是：https://www.baidu.com?cool=yes&amp;reach=no&amp;strong=yes</span></span><br><span class="line"><span class="comment">//所以需要根据&amp;符号来对刚才得到的pagename进行再次切割</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pagename.match(<span class="string">'&amp;'</span>)) &#123;</span><br><span class="line">	<span class="keyword">var</span> sliceEnd = pagename.indexOf(<span class="string">'&amp;'</span>);</span><br><span class="line">	pagneame = pagename.slice(<span class="string">'pagename='</span>.lenth, sliceEnd)	; <span class="comment">//dynamic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样就得到了用户点击时传过来的参数，通过参数再控制页面该做什么就ok了。</span></span><br></pre></td></tr></table></figure>
<p>如果读者有其他方法，敬请分享。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/27/通过url参数控制页面/" data-id="cji413o11000l08anbdm1hrnw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-cli里package.json解释" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/26/vue-cli里package.json解释/" class="article-date">
  <time datetime="2017-05-26T09:55:18.000Z" itemprop="datePublished">2017-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/26/vue-cli里package.json解释/">vue-cli里package.json解释</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这里简单解释下vue-cli的项目最外层都引入了什么组件 做什么用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#123; //这个代码块里的都是项目描述，是创建者自定义的</span><br><span class="line">  "name": "qqmusic",  //项目名称</span><br><span class="line">  "version": "1.0.0",   //项目版本</span><br><span class="line">  "description": "qq music app by vue", //项目描述</span><br><span class="line">  "author": "yangbo", //项目作者</span><br><span class="line">  "private": true, //是否为私有</span><br><span class="line">  "scripts": &#123; //这里是命名一些变量对应什么指令</span><br><span class="line">    "dev": "node build/dev-server.js", //运行dev 相当于运行node build/dev-server.js</span><br><span class="line">    "start": "node build/dev-server.js", //同上</span><br><span class="line">    "build": "node build/build.js", //同上</span><br><span class="line">    "lint": "eslint --ext .js,.vue src" //同上</span><br><span class="line">  &#125;,</span><br><span class="line">  "dependencies": &#123; //这个代码块描述此 项目依赖 的插件；下面两个做什么的自行搜索</span><br><span class="line">    "vue": "^2.2.6", </span><br><span class="line">    "vue-router": "^2.3.1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "devDependencies": &#123; //这个代码块里描述的是此项目 运行依赖 插件；注意根上面项目依赖的区分</span><br><span class="line">    "autoprefixer": "^6.7.2", //这英文翻译过来就是：自动 预 修复者，专业称呼知道的可以回复下；它是一个css前缀处理工具，有了它我们就不用写很多前缀了</span><br><span class="line">    "babel-core": "^6.22.1", //babel是es6编译工具，将es6 7语法编译成es5语法，以兼容不支持es6 7的浏览器，这个是babel的核心组件</span><br><span class="line">    "babel-eslint": "^7.1.1", //eslint是一个约束编码者的代码风格工具，这个是babel版本的eslint，如果那里写的不符合eslint的要求，就会报错，练习这个建议用熟练的项目来练习</span><br><span class="line">    "babel-loader": "^6.2.10", //这是babel的加载组件，有了它就可以让babel和webpack对我们的js文件进行处理转换</span><br><span class="line">    "babel-plugin-transform-runtime": "^6.22.0", //babel用来修复自己转换不足的一个组件 https://segmentfault.com/q/1010000005596587?from=singlemessage&amp;isappinstalled=1</span><br><span class="line">    "babel-preset-env": "^1.3.2", //智能识别当前运行环境，不支持es6 7才进行转换，在高性能浏览器上会保留高性能的es6 7语法</span><br><span class="line">    "babel-preset-stage-2": "^6.22.0", //stage0 1 2 3是babel编译范围的一个标准，2版本适合开发使用 http://www.cnblogs.com/chris-oil/p/5717544.html</span><br><span class="line">    "babel-register": "^6.22.0", //官方介绍它可以让babel-core自动钩到我们需要编译的地方，懂得请回复，方便大家</span><br><span class="line">    "chalk": "^1.1.3", // 代码的颜色是它帮忙实现的</span><br><span class="line">    "connect-history-api-fallback": "^1.3.0", //解决单页面应用刷新和直接通过域名+参数访问时候出现404的不足 https://github.com/bripkens/connect-history-api-fallback</span><br><span class="line">    "copy-webpack-plugin": "^4.0.1", //webpack的一个文件和目录复制工具，项目部分路径问题的解决者</span><br><span class="line">    "css-loader": "^0.28.0", //css加载组件，默认css不支持@import ../path/test.css 这种在一个css中引入另一个css的方式，而有了它，就可以这样引入了 http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece763105392230e54f73f7e88885468d4e419ce3b46031437bae872750d5592846b6777f1140fbca77666725e60e19499c90bcabae23f2ffe30350042db12448459&amp;p=8c769a47c09f05ff57ee957e610a86&amp;newp=8b2a97118d9159ff57ee957e500793231610db2151d7d5166b82c825d7331b001c3bbfb42324130fd3c0786707ac4b59eff23570310221a3dda5c91d9fb4c57479dc7c6668&amp;user=baidu&amp;fm=sc&amp;query=css-loader&amp;qid=b877345400022555&amp;p1=3</span><br><span class="line">    "eslint": "^3.19.0", //这是官方eslint，用于统一代码风格的工具，写的不符合规范就给报错，再次建议，在自己有把握的熟练项目里练习它比较好</span><br><span class="line">    "eslint-friendly-formatter": "^2.0.7", //个人理解为一个修复eslint导致编辑器打开文件异常的组件 https://www.npmjs.com/package/eslint-friendly-formatter</span><br><span class="line">    "eslint-loader": "^1.7.1", //eslint加载器，类似babel-loder功能</span><br><span class="line">    "eslint-plugin-html": "^2.0.0", //</span><br><span class="line">    "eslint-config-standard": "^6.2.1", //eslint的一个js标准样式配置组件，用于配置如何规定js代码规范的 http://npm.taobao.org/package/eslint-config-standard</span><br><span class="line">    "eslint-plugin-promise": "^3.4.0", //不清楚：难道是针对js的promise功能单独搞的组件？ 请高手回复 https://www.npmjs.com/package/eslint-plugin-promise</span><br><span class="line">    "eslint-plugin-standard": "^2.0.1", //eslint标准生产组件 https://www.npmjs.com/package/eslint-plugin-standard</span><br><span class="line">    "eventsource-polyfill": "^0.9.6", //不清楚：挺常见的单词，难道是解决跨域请求问题的？ 请高手回复 https://www.npmjs.com/package/eventsource</span><br><span class="line">    "express": "^4.14.1", //一个nodeJS常用的框架，超好用，集成很多常用功能，类似jquery的能力</span><br><span class="line">    "extract-text-webpack-plugin": "^2.0.0", //该组件可以解决webpak将css样式打包到js中出现样式错乱的问题 https://github.com/webpack-contrib/extract-text-webpack-plugin http://www.cnblogs.com/dyx-wx/p/6529447.html</span><br><span class="line">    "file-loader": "^0.11.1", //webpack的文件加载组件，解决路径问题的关键组件，</span><br><span class="line">    "friendly-errors-webpack-plugin": "^1.1.3", //报错的有个友好组件，当有报错，会将error信息显示在可视区域</span><br><span class="line">    "html-webpack-plugin": "^2.28.0", //帮助我们生成最终html文件的一个组件 https://www.npmjs.com/package/html-webpack-plugin</span><br><span class="line">    "http-proxy-middleware": "^0.17.3", //http代理中间件，这里用于辅助解决路径问题 https://www.npmjs.com/package/http-proxy-middleware</span><br><span class="line">    "webpack-bundle-analyzer": "^2.2.1", //很有意思的一个组件，用于优化压缩和查找错误模块 https://www.npmjs.com/package/webpack-bundle-analyzer</span><br><span class="line">    "semver": "^5.3.0", //不清楚：难道是版本规范工具？ http://semver.org/lang/zh-CN/</span><br><span class="line">    "shelljs": "^0.7.6", //为nodeJS提供的一个仿UNIX的shell命令的组件 https://www.npmjs.com/package/shelljs</span><br><span class="line">    "opn": "^4.0.2", //为nodeJS提供的一个跨平台打开文件的方法，</span><br><span class="line">    "optimize-css-assets-webpack-plugin": "^1.3.0", //</span><br><span class="line">    "ora": "^1.2.0", //不清楚：难道是提供一个识别参数文件的后缀功能？ https://zhidao.baidu.com/question/581436199.html</span><br><span class="line">    "rimraf": "^2.6.0", //为nodeJS提供的一个UNIX命令，rm -rf 移除文件的功能</span><br><span class="line">    "url-loader": "^0.5.8", //功能同file-loader，不过在它基础上增加了小于8kb的图片直接转换成base64码写进js，减少图片请求，节约资源</span><br><span class="line">    "vue-loader": "^11.3.4", // vue的加载工具，它允许我们使用vue的格式写文件 https://github.com/vuejs/vue-loader</span><br><span class="line">    "vue-style-loader": "^2.0.5", //webpack的vue.js样式加载模块 http://npm.taobao.org/package/vue-style-loader</span><br><span class="line">    "vue-template-compiler": "^2.2.6", //vue编译模板，用于将vue2.0+编译成可供浏览器渲染的常规正常函数 https://npm.taobao.org/package/vue-template-compiler</span><br><span class="line">    "webpack": "^2.3.3", //一款打包工具，还有其他功能，例如路径处理等</span><br><span class="line">    "webpack-dev-middleware": "^1.10.0", //本地改动，webpack相关功能都会实时刷新 https://github.com/webpack/webpack-dev-middleware</span><br><span class="line">    "webpack-hot-middleware": "^2.18.0", //开发时特有的一个中间件，我们本地测试文件的改动都会实时在内存缓存里存储，并没有写入磁盘；</span><br><span class="line">    "webpack-merge": "^4.1.0" //webpack合并文件的组件，我们写很多js文件，最后webpack会将它们合并成一个js，减少网络请求次数 https://www.npmjs.com/package/webpack-merge</span><br><span class="line">  &#125;,</span><br><span class="line">  "engines": &#123; // 引擎相关的内容</span><br><span class="line">    "node": "&gt;= 4.0.0", //要求node版本要大于指定版本，否则不给你运行~</span><br><span class="line">    "npm": "&gt;= 3.0.0" //要求npm版本大于指定版本</span><br><span class="line">  &#125;,</span><br><span class="line">  "browserslist": [ // 配置浏览器的信息查询范围，这些信息将给Autoprefixer babel-env-preset eslint-plugin-compat这些组件来使用 https://www.npmjs.com/package/browserslist</span><br><span class="line">    "&gt; 1%", //</span><br><span class="line">    "last 2 versions", //每种浏览器的最近的两个版本</span><br><span class="line">    "not ie &lt;= 8" //IE8及以下版本不查询</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/26/vue-cli里package.json解释/" data-id="cji413o06000408an68767pwa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/简单解释下vue-cli的项目最外层都引入了什么组件/">简单解释下vue-cli的项目最外层都引入了什么组件</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单解释下vue-cli的项目最外层都引入了什么组件/">简单解释下vue-cli的项目最外层都引入了什么组件</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/简单解释下vue-cli的项目最外层都引入了什么组件/" style="font-size: 10px;">简单解释下vue-cli的项目最外层都引入了什么组件</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/16/北京租房退押金之路/">北京租房退押金之路</a>
          </li>
        
          <li>
            <a href="/2017/11/01/放开那个IE8/">放开那个IE8</a>
          </li>
        
          <li>
            <a href="/2017/10/16/腾讯QQ手机电脑互传内容可能会泄露给陌生人！/">安全隐患：腾讯QQ手机电脑互传内容可能会泄露给陌生人！</a>
          </li>
        
          <li>
            <a href="/2017/08/23/css3里的贝塞尔速度曲线/">css3里的贝塞尔运动曲线</a>
          </li>
        
          <li>
            <a href="/2017/08/17/一个有意思的题目foo-x-foo-n-2/">一个有意思的题目foo.x = foo = {n: 2}</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>