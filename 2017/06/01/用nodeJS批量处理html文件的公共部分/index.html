<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>用nodeJS批量处理html文件 | starkL</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近接手一个任务，给一个集团写一个静态站点，看了设计稿发现除了首页，其他页面的头部nav和底部footer都是一样的。如果写好粘贴赋值粘贴复制，多累啊！————于是想到一个需求：     如何能让页面公用部分写一边，然后所有页面都能同步？    作为前端出身，技术栈又比较少~ 第一个想到的就是nodeJS了！毕竟JS是前端特有唯一一门编程语言了！  首先，屡屡思路：    目的是：公用部分单独写">
<meta property="og:type" content="article">
<meta property="og:title" content="用nodeJS批量处理html文件">
<meta property="og:url" content="http://yoursite.com/2017/06/01/用nodeJS批量处理html文件的公共部分/index.html">
<meta property="og:site_name" content="starkL">
<meta property="og:description" content="最近接手一个任务，给一个集团写一个静态站点，看了设计稿发现除了首页，其他页面的头部nav和底部footer都是一样的。如果写好粘贴赋值粘贴复制，多累啊！————于是想到一个需求：     如何能让页面公用部分写一边，然后所有页面都能同步？    作为前端出身，技术栈又比较少~ 第一个想到的就是nodeJS了！毕竟JS是前端特有唯一一门编程语言了！  首先，屡屡思路：    目的是：公用部分单独写">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tKfTcgy1fg886inyhzj30am03uq32.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tKfTcly1fghckwi0p5j307m0b8dg9.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tKfTcly1fghcoh0xv5j306400s748.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tKfTcly1fghcp1s4bmj30hs036dg5.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tKfTcly1fgi61eege0j30ri024wev.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tKfTcly1fgi809xc8lj30fo046mxx.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tKfTcly1fgi812xiskj30bq0dcmxr.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tKfTcly1fgi9i75b9yj30hg04idge.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tKfTcly1fgirvxjl9xj30gg0ayq3y.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tNbRwly1fgit2euk34j30je0gedhu.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNbRwly1fgitccgnncj30bo06agma.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tNbRwly1fgitd3zlxzj30ie0l4tau.jpg">
<meta property="og:updated_time" content="2018-01-06T13:44:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用nodeJS批量处理html文件">
<meta name="twitter:description" content="最近接手一个任务，给一个集团写一个静态站点，看了设计稿发现除了首页，其他页面的头部nav和底部footer都是一样的。如果写好粘贴赋值粘贴复制，多累啊！————于是想到一个需求：     如何能让页面公用部分写一边，然后所有页面都能同步？    作为前端出身，技术栈又比较少~ 第一个想到的就是nodeJS了！毕竟JS是前端特有唯一一门编程语言了！  首先，屡屡思路：    目的是：公用部分单独写">
<meta name="twitter:image" content="https://ws3.sinaimg.cn/large/006tKfTcgy1fg886inyhzj30am03uq32.jpg">
  
    <link rel="alternate" href="/atom.xml" title="starkL" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/other">other</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">starkL</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-用nodeJS批量处理html文件的公共部分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/01/用nodeJS批量处理html文件的公共部分/" class="article-date">
  <time datetime="2017-06-01T10:06:15.000Z" itemprop="datePublished">2017-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      用nodeJS批量处理html文件
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><br></p>
<p>最近接手一个任务，给一个集团写一个静态站点，看了设计稿发现除了首页，其他页面的头部nav和底部footer都是一样的。如果写好粘贴赋值粘贴复制，多累啊！————于是想到一个需求：</p>
<p><br><br><br>  </p>
<blockquote>
<p>如何能让页面公用部分写一边，然后所有页面都能同步？  </p>
</blockquote>
<p><br><br>作为前端出身，技术栈又比较少~ 第一个想到的就是nodeJS了！毕竟JS是前端特有唯一一门编程语言了！</p>
<hr>
<p><br><br><br><br>首先，屡屡思路：<br><br><br><br>  </p>
<ol>
<li>目的是：公用部分单独写一份，然后页面只需要写除了公用部分之外的即可。</li>
<li>前提是：如果出现异常，不能影响自己写的代码-&gt;所以要另外建立一个文件夹，用于存放node处理后的代码</li>
</ol>
<p><br><br><br>  </p>
<p>接下来，开始node编写：  </p>
<p><strong>section 1</strong><br><br><br>一、 首先在新建文件夹下创建两个文件夹：  </p>
<blockquote>
<p>app（写代码的地方）<br>public（生成代码的地方）<br>handile.js（nodeJS文件）</p>
</blockquote>
<p>目录结构如下：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fg886inyhzj30am03uq32.jpg" alt=""></p>
<p><br><br><br>  </p>
<p>二、 做到将app里的文件复制到public中<br>　　解析功能<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制文件用到node的fs模块，用到readFile,writeFile功能，然而如果用这两个语法，它的原理是将文件内容读取保存在内存中，然后再一次性写入一个文件</span></span><br><span class="line"><span class="comment">//想想，这样就会遇到一个问题：如果文件比较大，一次性读取和写入，会不会很吃内存。</span></span><br><span class="line"><span class="comment">//就像是这里要从水龙头取水，将旁边一个无法移动的大缸接满，如果选择一次性接一缸水，再倒到水缸里，这显然是不明智的</span></span><br><span class="line"><span class="comment">//考虑这一点，这里要用Stream流信息处理方式，就是读着写着，像有水管一样，上面流着，下面接着，这样可行性就更高了,代码如下：</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">origin, aim</span>) </span>&#123;</span><br><span class="line">	fs.createReadStream(origin).pipe(fs.createWriteStream(aim));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里pipe方法就是这里举例中的水管</span></span><br></pre></td></tr></table></figure></p>
<p><br><br>　　现在有了一个能连通数据流的水管了，这里要将水管入口接到水龙头上，出口接到大缸里  </p>
<p><br><br><br><br>　　但现在这里还遇到一个问题，app文件夹下是可能会有img css js等文件夹的，而这里的方法createReadStream只能读取指定的一个文件，<br><br><br><br>  </p>
<p> <strong>所以这里要有一个遍历app和hbuild目录的方法，把app目录里所有文件的路径遍历出来，给copy方法的origin参数，再将app目录里文件的路径名字中app替换为hbuild，传给copy方法的aim参数，这样如果app文件夹下有多个文件，就相当于这里创造了多条水管，每个水管只负责一个文件信息流的传输</strong></p>
<p><br><br>这里要用到readdir方法，这里选择同步读取，保证开水龙头，水管传输，水进入水缸的正确顺序，这样就不用promise来单独处理异步了。所以这里用readdirSync方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">	fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> pathname = path.join(dir, file); <span class="comment">//将遍历到文件的路径给变量pathname</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(fs.statSync(pathname).isDirectory()) &#123;<span class="comment">//判断是当前遍历到的文件是否是一个文件夹，如果是则进入文件夹再进行遍历：</span></span><br><span class="line">			travelSync(pathname, callback);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			callback(pathname);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<p>这样一个tranvel函数，需要两个参数，遍历的目录路径，和回调函数<br>这样这里就可以组合两个函数进行遍历和写入　　<br><br></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">travelSync(<span class="string">'./app'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pathname) &#123;</span><br><span class="line">		<span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>)</span><br><span class="line">			copy(pathname, publicPath);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelSync</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">	fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> pathname = path.join(dir, file);</span><br><span class="line">		<span class="built_in">console</span>.log(pathname)</span><br><span class="line">		<span class="keyword">if</span>(fs.statSync(pathname).isDirectory()) &#123;</span><br><span class="line">			travelSync(pathname, callback);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			callback(pathname);</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件复制成功！'</span>)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">src, dst</span>) </span>&#123;</span><br><span class="line">	fs.createReadStream(src).pipe(fs.createWriteStream(dst));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>这里在app文件夹里新建几个目录和文件来做测试<br><br><br><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fghckwi0p5j307m0b8dg9.jpg" alt=""></p>
<p>header index footer 三个html文件里分别写：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- header.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">this is header!</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">this is index.html</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- footer.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">this is footer!</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><br><br>然后在终端 cmd， 进入当前文件夹路径，执行 node handle.js　　<br><br><br><br></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fghcoh0xv5j306400s748.jpg" alt=""></p>
<p><br></p>
<p>然后再打开public文件夹，看下，发现：</p>
<p><br></p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fghcp1s4bmj30hs036dg5.jpg" alt=""></p>
<p>哎！what？ 为什么css img js文件夹和里面的文件没有复制过来？<br><br><br>这是因为这里在遍历目录的时候，copy方法只实现了文件流信息的传输，但没有实现文件夹创建功能，所以这样运行会出现报错：<br><br><br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fgi61eege0j30ri024wev.jpg" alt=""></p>
<p><br></p>
<p>那么接下来就要写cipyDir方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyDir</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">	fs.mkdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123; <span class="comment">//mkdir方法创建文件夹只需要通过第一个参数告诉node路径和文件夹名即可创建，简单暴力</span></span><br><span class="line">		<span class="keyword">if</span>(!err) <span class="built_in">console</span>.log(path+<span class="string">' 目录创建成功!'</span>)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里这里要修改一下travel方法，当travel遍历到文件夹的时候，在build文件夹下执行创建文件夹命令： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelSync</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">	fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> pathname = path.join(dir, file);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(fs.statSync(pathname).isDirectory()) &#123;</span><br><span class="line">			callback(pathname,<span class="string">'dir'</span>); <span class="comment">//新增：遇到文件夹也执行回调，并传入一个字符串用于告知回调函数知道这是一个文件夹的pathname</span></span><br><span class="line">			travelSync(pathname, callback);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			callback(pathname,<span class="string">'file'</span>);<span class="comment">//这里也添加告知回调函数文件类型的第二个参数'file'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来撸一遍现在的handle.js，是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">travelSync(<span class="string">'./app'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">pathname, fileType</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pathname &amp;&amp; fileType === <span class="string">'file'</span>) &#123;</span><br><span class="line">		<span class="comment">// app/header.html</span></span><br><span class="line">		<span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>);</span><br><span class="line">		copy(pathname, publicPath);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname &amp;&amp; fileType === <span class="string">'dir'</span>) &#123;</span><br><span class="line">		<span class="comment">// app/css</span></span><br><span class="line">		<span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>);</span><br><span class="line">		copyDir(publicPath)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelSync</span>(<span class="params">dir, callback</span>) </span>&#123;</span><br><span class="line">	fs.readdirSync(dir).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> pathname = path.join(dir, file);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(fs.statSync(pathname).isDirectory()) &#123;</span><br><span class="line">			callback(pathname,<span class="string">'dir'</span>);</span><br><span class="line">			travelSync(pathname, callback);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			callback(pathname,<span class="string">'file'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">path, aimPath</span>) </span>&#123;</span><br><span class="line">	fs.createReadStream(path).pipe(fs.createWriteStream(aimPath));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyDir</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">	fs.mkdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!err) <span class="built_in">console</span>.log(path+<span class="string">' 目录创建成功!'</span>)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok,现在再测试下复制功能是否能解决刚才无法复制文件夹的问题：命令行运行：node handle.js，打印出：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fgi809xc8lj30fo046mxx.jpg" alt=""></p>
<p>再看public文件夹目录：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fgi812xiskj30bq0dcmxr.jpg" alt=""></p>
<p>漂亮！现在复制功能已经达到。敲代码的，就是需要做好铺垫，才能快速行动~ 接下来进入关键时刻，处理文件的公用部分</p>
<hr>
<p><strong>section 2</strong></p>
<p><br></p>
<p>这里模拟测试将app里的header footer 整合到index.html的 头 和 尾。 现在要用到readFile 和 writeFile语法，读取header footer里指定的内容，再写入index指定位置。</p>
<p><br></p>
<p>这里先想一个问题：如果文件比较大，内容比较复杂，如何才能准确的找到header footer里面指定的代码段， 然后准确的写入index指定的位置？先别看下面解决方案，两分钟，看自己能想出哪些方法</p>
<p><br><br><br><br><br><br><br><br><br><br>我暂想到相对好用的方法是：</p>
<ol>
<li>在header footer文件需要截取的代码段头尾添加一个标记行注释标签，同样，在index里面也放一个注释标签，告诉handle.js准确位置</li>
</ol>
<p>也有一个不好用的：就是直接判断代码段开始标签，和结束标签，这样每次都要严格查询代码并做更改，其实挺麻烦的。</p>
<p><br><br>这里修改header  index  footer，添加标记注释，分别更改为：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- header begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">	this is header!</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- header end --&gt;</span></span><br><span class="line">```  </span><br><span class="line">```html</span><br><span class="line"><span class="comment">&lt;!-- index begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">	this is index.html</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- index end --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- footer begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">	this is footer!</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- footer end --&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来在heandle.js里写header footer代码段截取功能，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHeader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	fs.readFile(<span class="string">'./app/header.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> headerData = html.toString();</span><br><span class="line">		<span class="comment">// sliceStart只需要找到字符串的索引位置即可</span></span><br><span class="line">		<span class="keyword">var</span> sliceStart = headerData.indexOf(<span class="string">'&lt;!-- header begin --&gt;'</span>);</span><br><span class="line">		<span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span></span><br><span class="line">		<span class="keyword">var</span> sliceEnd = headerData.indexOf(<span class="string">'&lt;!-- header end --&gt;'</span>) + <span class="string">'&lt;!-- header end --&gt;'</span>.length+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">var</span> header = headerData.slice(sliceStart, sliceEnd);</span><br><span class="line">		<span class="built_in">console</span>.log(header)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">getHeader();</span><br></pre></td></tr></table></figure>
<p>命令行运行node handle.js后 看到：  </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fgi9i75b9yj30hg04idge.jpg" alt="">   </p>
<p>这样就准确找到想要的代码段了。<br>由于还需要用同样的方法找到index和footer代码段，所以这里将getHeader方法封装成一个getAimCode方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAimCode</span>(<span class="params">headerPath, flagBegin, flagEnd</span>) </span>&#123;</span><br><span class="line">  fs.readFile(headerPath, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">      <span class="keyword">var</span> headerData = html.toString();</span><br><span class="line">      <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span></span><br><span class="line">      <span class="keyword">var</span> sliceStart = headerData.indexOf(flagBegin);</span><br><span class="line">      <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span></span><br><span class="line">      <span class="keyword">var</span> sliceEnd = headerData.indexOf(flagEnd) + flagEnd.length+<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">var</span> header = headerData.slice(sliceStart, sliceEnd);</span><br><span class="line">      <span class="built_in">console</span>.log(header)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试以下用getAimCode获取footer代码段</span></span><br><span class="line">getAimCode(<span class="string">'./app/footer.html'</span>, <span class="string">'&lt;!-- footer begin --&gt;'</span>, <span class="string">'&lt;!-- footer end --&gt;'</span>);</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">封装函数最笨的办法：把可能会变动的内容，替换成参数变量，再通过函数调用，以参数的形式传进去，可以运行下上面代码，即可得到footer代码段，测试上面代码即可得到：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![](https://ws2.sinaimg.cn/large/006tKfTcly1fi7iyyrgl8j308i03ujrn.jpg)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">现在能找到需要截取的代码段，接下来要进行代码段的准确插入：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">其实插入代码段的基础原理，就是将目标文件信息读取出来，分为三段：</span></span><br><span class="line"><span class="string">1. 插入位置之前的代码段 top</span></span><br><span class="line"><span class="string">2. 插入header和footer之间的代码段 content </span></span><br><span class="line"><span class="string">3. 插入footer之后的代码段 bottom</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后只需要将代码段拼接成 top + header + content + footer + bottom 这么一个完整的代码块，再写入目标文件就完成了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">接下来对目标文件index进行分割：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为了明显看出index的分割效果，这里将index.html更改内容为：</span></span><br><span class="line"><span class="string"> `</span><span class="string">``</span>html</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;title&gt;index&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- index begin --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">	<span class="keyword">this</span> is index.html</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- index end --&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br><span class="line"> <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">回想下，从header.html中切出header代码段的时候，是找到</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>html</span><br><span class="line">&lt;!-- header begin --&gt;</span><br><span class="line">和</span><br><span class="line">&lt;!-- header end --&gt;</span><br></pre></td></tr></table></figure>
<p>两个标记的索引位置，用String.slice(start,end)方法来切割的。那么index的三段一样要找到top content bottom三者的开始位置和结束位置。这里先默认index文件的内容被读取为：indexData，那么：</p>
<pre><code class="html">1. top：是从文档的开始，开始位置就是索引值0，
2. 结束索引值就是index begin标记的开始，即indexData.indexOf('<span class="comment">&lt;!-- index begin --&gt;</span>');

3. content：开始索引值是indexData.indexOf('<span class="comment">&lt;!-- index begin --&gt;</span>');
4. 结束索引值是：indexData.indexOf('<span class="comment">&lt;!-- index end --&gt;</span>')+'<span class="comment">&lt;!-- index end --&gt;</span>'.length+2;

5. bottom：开始索引值是indexData.indexOf('<span class="comment">&lt;!-- index end --&gt;</span>')+'<span class="comment">&lt;!-- index end --&gt;</span>'.length+2,
6. bottom可以直接切到文档结尾，slice方法如果不传入第二个参数的话就默认直接从指定索引位置切割到结尾
</code></pre>
<p>这样就可以写出函数：</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">cutIndex</span>(<span class="params"></span>) </span>{
  fs.readFile(<span class="string">'./app/index.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>{
    <span class="keyword">if</span>(!err) {
      <span class="keyword">var</span> indexData = html.toString();
      <span class="keyword">var</span> topStart = <span class="number">0</span>,
        topEnd = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>);
      <span class="keyword">var</span> contentStart = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>),
        contentEnd = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;
      <span class="keyword">var</span> bottomStart = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;

      <span class="keyword">var</span> top = indexData.slice(topStart, topEnd),
        content = indexData.slice(contentStart, contentEnd),
        bottom = indexData.slice(bottomStart);
      <span class="built_in">console</span>.log(top+<span class="string">'top打印结束'</span>);
      <span class="built_in">console</span>.log(content+<span class="string">'content打印结束'</span>);
      <span class="built_in">console</span>.log(bottom+<span class="string">'\n bottom打印结束'</span>);
    }
  })
}
cutIndex();
</code></pre>
<p>命令行里执行：node handle.js<br>打印出：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fgirvxjl9xj30gg0ayq3y.jpg" alt="">  </p>
<p>现在得到了header footer top content bottom，接下来要做拼接并的功能。  </p>
<p>将我们的代码组装起来成为：</p>
<pre><code class="javascript">fs.readFile(<span class="string">'./app/header.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>{
    <span class="keyword">if</span>(!err) {
        <span class="keyword">var</span> headerData = html.toString();
        <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span>
        <span class="keyword">var</span> sliceStart = headerData.indexOf(<span class="string">'&lt;!-- header begin --&gt;'</span>);
        <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span>
        <span class="keyword">var</span> sliceEnd = headerData.indexOf(<span class="string">'&lt;!-- header end --&gt;'</span>) + <span class="string">'&lt;!-- header end --&gt;'</span>.length+<span class="number">2</span>;
        <span class="keyword">var</span> header = headerData.slice(sliceStart, sliceEnd);
    }

    fs.readFile(<span class="string">'./app/footer.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>{
        <span class="keyword">if</span>(!err) {
            <span class="keyword">var</span> footerData = html.toString();
            <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span>
            <span class="keyword">var</span> sliceStart = footerData.indexOf(<span class="string">'&lt;!-- footer begin --&gt;'</span>);
            <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span>
            <span class="keyword">var</span> sliceEnd = footerData.indexOf(<span class="string">'&lt;!-- footer end --&gt;'</span>) + <span class="string">'&lt;!-- footer end --&gt;'</span>.length+<span class="number">2</span>;
            <span class="keyword">var</span> footer = footerData.slice(sliceStart, sliceEnd);
        }

        fs.readFile(<span class="string">'./app/index.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>{
            <span class="keyword">if</span>(!err) {
                <span class="keyword">var</span> indexData = html.toString();
                <span class="keyword">var</span> topStart = <span class="number">0</span>,
                    topEnd = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>);
                <span class="keyword">var</span> contentStart = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>),
                    contentEnd = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;
                <span class="keyword">var</span> bottomStart = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;

                <span class="keyword">var</span> top = indexData.slice(topStart, topEnd),
                    content = indexData.slice(contentStart, contentEnd),
                    bottom = indexData.slice(bottomStart);
            }
            <span class="built_in">console</span>.log(top+header+content+footer+bottom);
        })
    })
})
</code></pre>
<p>执行代码就可以得到：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fgit2euk34j30je0gedhu.jpg" alt="">  </p>
<p>最终，结合section1，handle.js要完成：</p>
<ol>
<li>先将app文件夹的目录结构复制到public文佳夹下</li>
<li>对文件切割完毕，重组合，再写入public文件夹下的index.html中</li>
</ol>
<p>基础版最终代码如下：</p>
<pre><code class="javascript">travelSync(<span class="string">'./app'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">pathname, fileType</span>) </span>{
    <span class="keyword">if</span>(pathname &amp;&amp; fileType === <span class="string">'file'</span>) {
        <span class="comment">// app/header.html</span>
        <span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>);
        copy(pathname, publicPath);
    } <span class="keyword">else</span> <span class="keyword">if</span> (pathname &amp;&amp; fileType === <span class="string">'dir'</span>) {
        <span class="comment">// app/css</span>
        <span class="keyword">var</span> publicPath = pathname.replace(<span class="string">'app'</span>, <span class="string">'public'</span>);
        copyDir(publicPath)
    }

    fs.readFile(<span class="string">'./app/header.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>{
        <span class="keyword">if</span>(!err) {
            <span class="keyword">var</span> headerData = html.toString();
            <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span>
            <span class="keyword">var</span> sliceStart = headerData.indexOf(<span class="string">'&lt;!-- header begin --&gt;'</span>);
            <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span>
            <span class="keyword">var</span> sliceEnd = headerData.indexOf(<span class="string">'&lt;!-- header end --&gt;'</span>) + <span class="string">'&lt;!-- header end --&gt;'</span>.length+<span class="number">2</span>;
            <span class="keyword">var</span> header = headerData.slice(sliceStart, sliceEnd);
        }

        fs.readFile(<span class="string">'./app/footer.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>)</span>{
            <span class="keyword">if</span>(!err) {
                <span class="keyword">var</span> footerData = html.toString();
                <span class="comment">// sliceStart只需要找到字符串的索引位置即可</span>
                <span class="keyword">var</span> sliceStart = footerData.indexOf(<span class="string">'&lt;!-- footer begin --&gt;'</span>);
                <span class="comment">// sliceEnd找到字符串的位置后，加上字符串本身的长度再加2是一个换行符的</span>
                <span class="keyword">var</span> sliceEnd = footerData.indexOf(<span class="string">'&lt;!-- footer end --&gt;'</span>) + <span class="string">'&lt;!-- footer end --&gt;'</span>.length+<span class="number">2</span>;
                <span class="keyword">var</span> footer = footerData.slice(sliceStart, sliceEnd);
            }

            fs.readFile(<span class="string">'./app/index.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, html</span>) </span>{
                <span class="keyword">if</span>(!err) {
                    <span class="keyword">var</span> indexData = html.toString();
                    <span class="keyword">var</span> topStart = <span class="number">0</span>,
                        topEnd = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>);
                    <span class="keyword">var</span> contentStart = indexData.indexOf(<span class="string">'&lt;!-- index begin --&gt;'</span>),
                        contentEnd = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;
                    <span class="keyword">var</span> bottomStart = indexData.indexOf(<span class="string">'&lt;!-- index end --&gt;'</span>)+<span class="string">'&lt;!-- index end --&gt;'</span>.length+<span class="number">2</span>;

                    <span class="keyword">var</span> top = indexData.slice(topStart, topEnd),
                        content = indexData.slice(contentStart, contentEnd),
                        bottom = indexData.slice(bottomStart);
                }
                <span class="keyword">var</span> indexChunk = top+header+content+footer+bottom;
                fs.writeFile(<span class="string">'./public/index.html'</span>, indexChunk, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
                    <span class="keyword">if</span>(!err) <span class="built_in">console</span>.log(<span class="string">'文件处理成功！'</span>)
                })
            })
        })
    })
})
</code></pre>
<p>再次在命令行里执行：node handle.js<br>终端输出：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fgitccgnncj30bo06agma.jpg" alt="">  </p>
<p>再打开public/index.html，就变成了：  </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fgitd3zlxzj30ie0l4tau.jpg" alt="">  </p>
<p>这里node命令是异步处理，所以出现代码嵌套非常多，稍微改动就成了传说中的回调地狱~   </p>
<p>后续更新promise优化版。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/01/用nodeJS批量处理html文件的公共部分/" data-id="cji46oxlz000i58an4835neiv" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2017/06/01/第一次webpack使用流程/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          第一次webpack使用流程
        
      </div>
    </a>
  
  
    <a href="/2017/05/30/我的胃出血/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">我的胃出血</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/07/web模拟微信悬浮球/">web模拟微信悬浮球</a>
          </li>
        
          <li>
            <a href="/2017/11/16/北京租房退押金之路/">北京租房退押金之路</a>
          </li>
        
          <li>
            <a href="/2017/11/01/放开那个IE8/">放开那个IE8</a>
          </li>
        
          <li>
            <a href="/2017/10/16/腾讯QQ手机电脑互传内容可能会泄露给陌生人！/">安全隐患：腾讯QQ手机电脑互传内容可能会泄露给陌生人！</a>
          </li>
        
          <li>
            <a href="/2017/08/23/css3里的贝塞尔速度曲线/">css3里的贝塞尔运动曲线</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 starkL&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;nicaicai@outlook.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/other" class="mobile-nav-link">other</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>